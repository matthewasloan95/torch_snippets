{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "8a7c7fb4-3938-4ef9-a9fa-7878e95606c8",
   "metadata": {},
   "outputs": [],
   "source": [
    "# | default_exp attrdict"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "ddaaf5c2-91fb-4b9a-b978-72a1b85d2c1b",
   "metadata": {},
   "outputs": [],
   "source": [
    "import hashlib\n",
    "from copy import deepcopy\n",
    "\n",
    "# %% ../nbs/markups.ipynb 2\n",
    "import json\n",
    "import os\n",
    "from collections.abc import Mapping\n",
    "from json import JSONEncoder\n",
    "from typing import Union, List\n",
    "\n",
    "import jsonlines\n",
    "import xmltodict\n",
    "import yaml\n",
    "\n",
    "from torch_snippets.icecream import ic\n",
    "from torch_snippets.loader import BB, L, np, pd\n",
    "from torch_snippets.logger import *\n",
    "from torch_snippets.paths import *\n",
    "from torch_snippets.thinc_parser.parser import Config"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "999f8148-49df-4c56-8c8c-d672c221a0b1",
   "metadata": {},
   "outputs": [],
   "source": [
    "def _default(self, obj):\n",
    "    import numpy as np\n",
    "    from datetime import datetime, date\n",
    "\n",
    "    if isinstance(obj, P):\n",
    "        return str(obj)\n",
    "    if isinstance(obj, AD):\n",
    "        return obj.to_dict()\n",
    "    if isinstance(obj, (set, L)):\n",
    "        return list(obj)\n",
    "    try:\n",
    "        import torch\n",
    "\n",
    "        if isinstance(obj, torch.Tensor):\n",
    "            obj = obj.cpu().detach().numpy()\n",
    "    except:\n",
    "        ...\n",
    "    if isinstance(obj, np.ndarray):\n",
    "        return obj.tolist()\n",
    "    if isinstance(obj, (datetime, date)):\n",
    "        return obj.isoformat()\n",
    "    return getattr(obj.__class__, \"__json__\", _default.default)(obj)\n",
    "\n",
    "\n",
    "_default.default = JSONEncoder().default\n",
    "JSONEncoder.default = _default\n",
    "\n",
    "\n",
    "def isnamedtupleinstance(x):\n",
    "    _type = type(x)\n",
    "    bases = _type.__bases__\n",
    "    if len(bases) != 1 or bases[0] != tuple:\n",
    "        return False\n",
    "    fields = getattr(_type, \"_fields\", None)\n",
    "    if not isinstance(fields, tuple):\n",
    "        return False\n",
    "    return all(type(i) == str for i in fields)\n",
    "\n",
    "\n",
    "def unpack(obj):\n",
    "    if isinstance(obj, dict):\n",
    "        return {key: unpack(value) for key, value in obj.items()}\n",
    "    elif isinstance(obj, list):\n",
    "        return [unpack(value) for value in obj]\n",
    "    elif isnamedtupleinstance(obj):\n",
    "        return {key: unpack(value) for key, value in obj._asdict().items()}\n",
    "    elif isinstance(obj, tuple):\n",
    "        return tuple(unpack(value) for value in obj)\n",
    "    else:\n",
    "        return obj\n",
    "\n",
    "\n",
    "def hash_tensor(tensor, n=8):\n",
    "    import torch\n",
    "\n",
    "    assert isinstance(tensor, torch.Tensor)\n",
    "    try:\n",
    "        tensor_str = tensor.cpu().detach().numpy().tobytes()\n",
    "    except:\n",
    "        ...\n",
    "    hash_obj = hashlib.sha256(tensor_str)\n",
    "    return \"ID:#\" + hash_obj.hexdigest()[:n]\n",
    "\n",
    "\n",
    "def hash_pandas_dataframe(input):\n",
    "    try:\n",
    "        from pandas.util import hash_pandas_object\n",
    "\n",
    "        h = hash_pandas_object(input, index=True).values\n",
    "        return \"ID:#\" + hashlib.sha256(h).hexdigest()[:6]\n",
    "    except:\n",
    "        return \"ID:#<uncomputable>\"\n",
    "\n",
    "\n",
    "def is_attrdict_like(input):\n",
    "    o = isinstance(input, (Mapping, AttrDict)) or all(\n",
    "        [hasattr(input, k) for k in [\"keys\", \"values\", \"items\"]]\n",
    "    )\n",
    "    return o\n",
    "\n",
    "\n",
    "class AttrDict(object):\n",
    "    \"\"\"\n",
    "    Utility class to interact with a dictionary as if it were an object. `AD` is an alias to this class\n",
    "\n",
    "    FEATURES:\n",
    "    0. Access and modify keys (including nested keys) as if they were object attributes, supporting tab-completion.\n",
    "       Example: `self.key1.key2[0].key3`\n",
    "    1. Keys and values are recursively converted to AttrDict instances.\n",
    "    2. Pretty-print the dictionary using `print`.\n",
    "    3. Convert the entire structure to a regular dictionary at any time using `self.to_dict() / self.dict()`.\n",
    "    3. Recursively remove keys using `self.drop(key)` from a JSON object.\n",
    "    4. Apply a function to all values at all levels using `map`.\n",
    "\n",
    "    GOTCHAS:\n",
    "    1. All integer keys are implicitly converted to strings due to the enforced `self.key` format.\n",
    "    2. You can still use `self[int]`, but this internally converts the integer to a string.\n",
    "\n",
    "    METHODS:\n",
    "    - `items()`: Return the items of the AttrDict as key-value pairs.\n",
    "    - `keys()`: Return the keys of the AttrDict.\n",
    "    - `values()`: Return the values of the AttrDict.\n",
    "    - `update(dict)`: Update the AttrDict with key-value pairs from another dictionary.\n",
    "    - `get(key, default=None)`: Get the value associated with a key, with an optional default value.\n",
    "    - `__iter__()`: Allow iteration over the keys of the AttrDict.\n",
    "    - `__len__()`: Return the number of keys in the AttrDict.\n",
    "    - `__repr__()`: Return a string representation of the AttrDict.\n",
    "    - `__dir__()`: List the keys of the AttrDict as attributes.\n",
    "    - `__contains__(key)`: Check if a key exists in the AttrDict, use 'a.b.c' notation to directly check for a nested attribute.\n",
    "    - `__delitem__(key)`: Delete a key from the AttrDict.\n",
    "    - `map(func)`: Apply a function to all values in the AttrDict.\n",
    "    - `drop(key)`: Recursively remove a key and its values from the AttrDict.\n",
    "    - `to_dict()`: Convert the AttrDict and its nested structure to a regular dictionary.\n",
    "    - `pretty(print_with_logger=False, *args, **kwargs)`: Pretty-print the AttrDict as JSON.\n",
    "    - `__eq__(other)`: Compare the AttrDict with another dictionary for equality.\n",
    "    - `find_address(key, current_path=\"\")`: Find and return all addresses (paths) of a given key in the AttrDict.\n",
    "    - `summary(current_path='', summary_str='', depth=0, sep='\\t')`: Generate a summary of the structure and values in the AttrDict.\n",
    "    - `write_summary(to, **kwargs)`: Write the summary to a file or stream.\n",
    "    - `fetch(addr)`: Retrieve a value at a specified address (path).\n",
    "\n",
    "    PARAMETERS:\n",
    "    - `data` (dict, optional): Initial data to populate the AttrDict.\n",
    "\n",
    "    USAGE:\n",
    "    - Create an AttrDict instance by providing an optional initial dictionary, and then access and manipulate its contents as if they were object attributes.\n",
    "\n",
    "    EXAMPLE:\n",
    "    ```python\n",
    "    my_dict = {'name': 'John', 'age': 30, 'address': {'city': 'New York', 'zip': '10001'}}\n",
    "    attr_dict = AttrDict(my_dict)\n",
    "    print(attr_dict.name)  # Access values like attributes\n",
    "    attr_dict.address.city = 'Los Angeles'  # Modify nested values\n",
    "    ```\n",
    "    \"\"\"\n",
    "\n",
    "    forbidden = set(\":,'\\\"}{.\")\n",
    "\n",
    "    def __init__(self, *args, given_input_to_ad=None, **kwargs):\n",
    "        given_input_to_ad = {} if given_input_to_ad is None else given_input_to_ad\n",
    "        if len(args) == 1 and isinstance(args[0], (Mapping, AttrDict)):\n",
    "            given_input_to_ad = args[0]\n",
    "            args = {}\n",
    "        else:\n",
    "            _args = dict(ic.io(*args)) if len(args) > 0 else {}\n",
    "            args = {}\n",
    "            for k in reversed(list(_args.keys())):\n",
    "                v = _args[k]\n",
    "                if any(c in self.forbidden for c in k):\n",
    "                    assert isinstance(\n",
    "                        v, (dict, AttrDict)\n",
    "                    ), f\"Input `{v}` can't be a list\"\n",
    "                    given_input_to_ad = {**v, **given_input_to_ad}\n",
    "                else:\n",
    "                    args = {**{k: v}, **args}\n",
    "\n",
    "        assert not any(\n",
    "            k in list(kwargs.keys()) for k in args.keys()\n",
    "        ), \"Keys in args and kwargs overlap\"\n",
    "        given_input_to_ad = {**args, **given_input_to_ad, **kwargs}\n",
    "        for name, value in given_input_to_ad.items():\n",
    "            setattr(self, str(name), self._wrap(value))\n",
    "\n",
    "    def __call__(self, **kwargs):\n",
    "        o = deepcopy(self)\n",
    "        for key in kwargs:\n",
    "            o[key] = kwargs[key]\n",
    "\n",
    "    def items(self):\n",
    "        return self.__dict__.items()\n",
    "\n",
    "    def keys(self):\n",
    "        return self.__dict__.keys()\n",
    "\n",
    "    def values(self):\n",
    "        return self.__dict__.values()\n",
    "\n",
    "    def __json__(self):\n",
    "        return self.to_dict()\n",
    "\n",
    "    def _wrap(self, value):\n",
    "        if isinstance(value, (L, tuple, list, set, frozenset)):\n",
    "            value = type(value)([self._wrap(v) for v in value])\n",
    "            if isinstance(value, (list, L)):\n",
    "                value = L(value)\n",
    "            return value\n",
    "        else:\n",
    "            return (\n",
    "                AttrDict(given_input_to_ad=value) if isinstance(value, dict) else value\n",
    "            )\n",
    "\n",
    "    __getitem__ = lambda self, x: (\n",
    "        AttrDict({_x: self[_x] for _x in x})\n",
    "        if isinstance(x, (list, L))\n",
    "        else getattr(self, str(x))\n",
    "    )\n",
    "    __setitem__ = lambda self, k, v: setattr(self, str(k), self._wrap(v))\n",
    "\n",
    "    def update(self, input):\n",
    "        input = AD(input)\n",
    "        for k, v in input.items():\n",
    "            self[k] = v\n",
    "\n",
    "    def get(self, key, default=None):\n",
    "        return self.fetch(key) if key in self else default\n",
    "\n",
    "    def set(self, key, value):\n",
    "        if \".\" in key:\n",
    "            _keys = key.split(\".\")\n",
    "            leaf = _keys[-1]\n",
    "        else:\n",
    "            _keys = [key]\n",
    "            leaf = key\n",
    "        for _key in _keys:\n",
    "            if _key not in self and key != leaf:\n",
    "                self[_key] = AD()\n",
    "            if _key == leaf:\n",
    "                self[_key] = value\n",
    "            self = self[_key]\n",
    "\n",
    "    def __iter__(self):\n",
    "        return iter(self.keys())\n",
    "\n",
    "    def __len__(self):\n",
    "        return len(self.keys())\n",
    "\n",
    "    def __repr__(self):\n",
    "        return f\"\\n```↯ AttrDict ↯\\n{self.summary()}\\n```\\n\"\n",
    "\n",
    "    def __dir__(self):\n",
    "        return self.__dict__.keys()\n",
    "\n",
    "    def __contains__(self, key):\n",
    "        key = str(key)\n",
    "        if \".\" not in key:\n",
    "            return key in self.__dict__.keys()\n",
    "        else:\n",
    "            d = self\n",
    "            for _k in key.split(\".\"):\n",
    "                try:\n",
    "                    d = d[_k]\n",
    "                except AttributeError:\n",
    "                    return False\n",
    "            return True\n",
    "\n",
    "    def __delitem__(self, key):\n",
    "        key = str(key)\n",
    "        del self.__dict__[key]\n",
    "\n",
    "    def map(self, func, _try=False):\n",
    "        if _try:\n",
    "\n",
    "            def tryfunc(func):\n",
    "                def inner(x):\n",
    "                    try:\n",
    "                        o = func(x)\n",
    "                    except:\n",
    "                        o = x\n",
    "                    return o\n",
    "\n",
    "                return inner\n",
    "\n",
    "            _func = tryfunc(func)\n",
    "\n",
    "        else:\n",
    "            _func = func\n",
    "\n",
    "        d = deepcopy(self)\n",
    "        for k in dir(d):\n",
    "            v = d[k]\n",
    "            if isinstance(v, AttrDict):\n",
    "                v = v.map(_func)\n",
    "            elif isinstance(v, (L, tuple, list, set, frozenset)):\n",
    "                v = [\n",
    "                    _v.map(_func) if isinstance(_v, AttrDict) else _func(_v) for _v in v\n",
    "                ]\n",
    "            else:\n",
    "                v = _func(v)\n",
    "            d[k] = v\n",
    "        return d\n",
    "\n",
    "    def trymap(self, func):\n",
    "        return self.map(func, _try=True)\n",
    "\n",
    "    def drop(self, key):\n",
    "        if key in self:\n",
    "            del self[key]\n",
    "        for k in dir(self):\n",
    "            v = self[k]\n",
    "            if isinstance(v, AttrDict):\n",
    "                v.drop(key)\n",
    "            if isinstance(v, (L, tuple, list, set, frozenset)):\n",
    "                v = [_v.drop(key) for _v in v if isinstance(_v, AttrDict)]\n",
    "\n",
    "    def to_dict(self):\n",
    "        d = {}\n",
    "        for k in self.__dict__.keys():  # can't use dir here\n",
    "            v = self[k]\n",
    "            if isinstance(v, AttrDict):\n",
    "                v = v.to_dict()\n",
    "            if isinstance(v, (L, tuple, list, set, frozenset)):\n",
    "                v = [_v.to_dict() if isinstance(_v, AttrDict) else _v for _v in v]\n",
    "            d[k] = v\n",
    "        return d\n",
    "\n",
    "    dict = to_dict\n",
    "\n",
    "    def pretty(self, print_with_logger=False, *args, **kwargs):\n",
    "        pretty_json(\n",
    "            self.to_dict(), print_with_logger=print_with_logger, *args, **kwargs\n",
    "        )\n",
    "\n",
    "    def __eq__(self, other):\n",
    "        return AttrDict(given_input_to_ad=other).to_dict() == self.to_dict()\n",
    "\n",
    "    def find_address(self, key, current_path=\"\"):\n",
    "        addresses = []\n",
    "        for k in self.keys():\n",
    "            if current_path:\n",
    "                new_path = f\"{current_path}.{k}\"\n",
    "            else:\n",
    "                new_path = k\n",
    "\n",
    "            if k == key:\n",
    "                addresses.append(new_path)\n",
    "\n",
    "            if isinstance(self[k], AttrDict):\n",
    "                addresses.extend(self[k].find_address(key, new_path))\n",
    "\n",
    "            elif isinstance(self[k], (L, tuple, list, set, frozenset)):\n",
    "                for i, item in enumerate(self[k]):\n",
    "                    if isinstance(item, AttrDict):\n",
    "                        addresses.extend(item.find_address(key, f\"{new_path}.{i}\"))\n",
    "        return addresses\n",
    "\n",
    "    def summary(self, current_path=\"\", depth=0, sep=\"  \", max_items=10):\n",
    "        max_items = int(os.environ.get(\"AD_MAX_ITEMS\", max_items))\n",
    "        if os.environ.get(\"AD_SHOW_TAB_STOPS\", False):\n",
    "            sep = \"⋮ \"\n",
    "        sep = os.environ.get(\"AD_SEP\", sep)\n",
    "\n",
    "        def format_path(path, key):\n",
    "            return f\"{path}.{key}\" if path else key\n",
    "\n",
    "        def format_item(key, item, path, depth, sep):\n",
    "            import numpy as np\n",
    "            import pandas as pd\n",
    "\n",
    "            try:\n",
    "                import torch\n",
    "            except ModuleNotFoundError:\n",
    "\n",
    "                class Torch:\n",
    "                    Tensor = type(...)\n",
    "\n",
    "                torch = Torch()\n",
    "\n",
    "            if isinstance(item, (pd.DataFrame,)):\n",
    "                return f\"{sep * depth}{key} - {type(item).__name__} - shape {item.shape} - columns {item.columns} - {hash_pandas_dataframe(item)}\\n\"\n",
    "            if isinstance(item, AttrDict) or hasattr(item, \"keys\"):\n",
    "                item = AttrDict(**item)\n",
    "                return f\"{sep*depth}{key}\\n\" + item.summary(path, depth + 1, sep)\n",
    "            elif isinstance(item, (list, tuple, set, frozenset, L)):\n",
    "                return summarize_collection(key, item, path, depth + 1, sep)\n",
    "            elif isinstance(item, (torch.Tensor, np.ndarray)):\n",
    "                is_np = False\n",
    "                if isinstance(item, np.ndarray):\n",
    "                    is_np = True\n",
    "                    try:\n",
    "                        item = torch.tensor(item)\n",
    "                    except:\n",
    "                        item = torch.tensor(item.copy())\n",
    "                is_np = \"🔦\" if not is_np else \"np.\"\n",
    "                return f\"{sep * depth}{key} - {is_np}{item} - {hash_tensor(item)}\\n\"\n",
    "\n",
    "            else:\n",
    "                is_multiline = False\n",
    "                ogitem = item\n",
    "                if isinstance(item, (str, P)):\n",
    "                    item = str(item)\n",
    "                    is_multiline = \"\\n\" in item\n",
    "                    _sep = \" ...\\n...\\n...\\n...\\n... \" if is_multiline else \".........\"\n",
    "                    if len(item) > 100:\n",
    "                        item = item[:35] + _sep + item[-35:]\n",
    "                    if is_multiline:\n",
    "                        _item = item.split(\"\\n\")\n",
    "                        _item = \"\\n\".join([f\"{sep*(depth+1)}{l}\" for l in _item])\n",
    "                        item = f\"↓\\n{sep*(depth+1)}```\\n{_item}\\n{sep*(depth+1)}```\"\n",
    "                multiline = \"\" if not is_multiline else \"Multiline \"\n",
    "                return f\"{sep * depth}{key} - {item} (🏷️ {multiline}{type(ogitem).__name__})\\n\"\n",
    "\n",
    "        def summarize_collection(key, collection, path, d, s):\n",
    "            if isinstance(collection, (L, list)):\n",
    "                info = \"[]\"\n",
    "            elif isinstance(collection, tuple):\n",
    "                info = \"()\"\n",
    "            else:\n",
    "                info = \"{}\"\n",
    "            summary_str = f\"{s * (d - 1)}{key}{info}\\n\"\n",
    "            for i, item in enumerate(collection):\n",
    "                item_path = format_path(path, i)\n",
    "                if i < max_items:\n",
    "                    summary_str += format_item(i, item, item_path, d, s)\n",
    "                else:\n",
    "                    summary_str += (\n",
    "                        f\"{s*d}... {len(collection) - max_items} more items ...\\n\"\n",
    "                    )\n",
    "                    break\n",
    "            return summary_str\n",
    "\n",
    "        summary_str = \"\"\n",
    "        for ix, key in enumerate(self.keys()):\n",
    "            if ix >= max_items:\n",
    "                summary_str += (\n",
    "                    f\"{sep*depth} ... {len(self.keys()) - max_items} more keys ...\\n\"\n",
    "                )\n",
    "                break\n",
    "            new_path = format_path(current_path, key)\n",
    "            summary_str += format_item(key, self[key], new_path, depth, sep)\n",
    "        return summary_str\n",
    "\n",
    "    def print_summary(self, **kwargs):\n",
    "        from builtins import print\n",
    "\n",
    "        print(self.summary(**kwargs))\n",
    "\n",
    "    def write_summary(self, to, **kwargs):\n",
    "        writelines(self.summary(sep=\"\\t\", **kwargs).split(\"\\n\"), to, mode=\"w\")\n",
    "\n",
    "    def fetch(self, addr):\n",
    "        if isinstance(addr, (list, L)):\n",
    "            return L([self.fetch(_addr) for _addr in addr])\n",
    "\n",
    "        o = self\n",
    "        for p in addr.split(\".\"):\n",
    "            try:\n",
    "                o = o[int(p)]\n",
    "            except:\n",
    "                o = o[p]\n",
    "        return o\n",
    "\n",
    "    def merge_addersses(self, ADs):\n",
    "        \"\"\"Given a list of ADs, merge them into a single AD, which recursively merging the addresses\n",
    "        E.g. When input is\n",
    "        ```↯ AttrDict ↯\n",
    "        01f3daf0-f33a-11ee-a30b-129eb4343ebc.metrics.old.0.recall - 0.5 (🏷️ float)\n",
    "        ```\n",
    "        ,\n",
    "        ```↯ AttrDict ↯\n",
    "        01f3daf0-f33a-11ee-a30b-129eb4343ebc.metrics.new.0.recall - 0.7566584022717563 (🏷️ float)\n",
    "        ```\n",
    "        ,\n",
    "        ```↯ AttrDict ↯\n",
    "        01f3daf0-f33a-11ee-a30b-129eb4343ebc.metrics.new.1.recall - 0.8080808080808081 (🏷️ float)\n",
    "        ```\n",
    "        ,\n",
    "        ```↯ AttrDict ↯\n",
    "        01f3db47-f33a-11ee-a30d-129eb4343ebc.metrics.old.0.recall - 0.5 (🏷️ float)\n",
    "        ```\n",
    "        Output will be\n",
    "        ```↯ AttrDict ↯\n",
    "        01f3daf0-f33a-11ee-a30b-129eb4343ebc\n",
    "          metrics\n",
    "            old[]\n",
    "              0\n",
    "                recall - 0.5 (🏷️ float)\n",
    "            new[]\n",
    "              0\n",
    "                recall - 0.7566584022717563 (🏷️ float)\n",
    "              1\n",
    "                recall - 0.8080808080808081 (🏷️ float)\n",
    "        01f3db47-f33a-11ee-a30d-129eb4343ebc\n",
    "          metrics\n",
    "            old[]\n",
    "              0\n",
    "                recall - 0.5 (🏷️ float)\n",
    "        ```\n",
    "        \"\"\"\n",
    "        o = AttrDict()\n",
    "        for ad in ADs:\n",
    "            for k in ad.keys():\n",
    "                o.set(k, ad[k])\n",
    "        return o\n",
    "\n",
    "    def flatten(self):\n",
    "        \"\"\"Flatten the AD into a single level AD with keys as dot combined keys\"\"\"\n",
    "        o = AttrDict()\n",
    "        for k in self.keys():\n",
    "            v = self[k]\n",
    "            if is_attrdict_like(v):\n",
    "                v = v.flatten()\n",
    "                for _k in v.keys():\n",
    "                    o[f\"{k}.{_k}\"] = v[_k]\n",
    "            elif isinstance(v, (list, tuple, set, frozenset, L)):\n",
    "                for i, _v in enumerate(v):\n",
    "                    if is_attrdict_like(_v):\n",
    "                        _v = _v.flatten()\n",
    "                        for _k, __v in _v.items():\n",
    "                            o[f\"{k}.{i}.{_k}\"] = __v\n",
    "                    else:\n",
    "                        o[f\"{k}.{i}\"] = _v\n",
    "            else:\n",
    "                o[k] = v\n",
    "        return o\n",
    "\n",
    "    def fetch2(self, *, key=None, addrs=None):\n",
    "        \"\"\"given dot notation address/addresses fetch the value while maintaining the original structure\"\"\"\n",
    "        if key is not None:\n",
    "            addrs = self.find_address(key)\n",
    "        if isinstance(addrs, (list, L)):\n",
    "            return self.merge_addersses(\n",
    "                L([self.fetch2(addrs=_addr) for _addr in addrs])\n",
    "            )\n",
    "\n",
    "        o = self\n",
    "        for p in addrs.split(\".\"):\n",
    "            try:\n",
    "                o = o[int(p)]\n",
    "            except:\n",
    "                o = o[p]\n",
    "        return AttrDict({addrs: o})\n",
    "\n",
    "    def write_config(self, to):\n",
    "        c = Config(self.dict())\n",
    "        c.to_disk(to)\n",
    "        return P(to)\n",
    "\n",
    "    def slice(self, key):\n",
    "        ks = self.find_address(key)\n",
    "        vs = self.fetch(ks)\n",
    "        return AttrDict(dict(zip(ks, vs)))\n",
    "\n",
    "    def flatten_and_make_dataframe(self):\n",
    "        import pandas as pd\n",
    "\n",
    "        df = pd.DataFrame([(*k.split(\".\"), v) for k, v in self.flatten().items()])\n",
    "        return df\n",
    "\n",
    "\n",
    "AD = AttrDict"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 4,
   "id": "0b15c8fc-5aae-4f0e-8c5c-b2a39b68bd8c",
   "metadata": {},
   "outputs": [],
   "source": [
    "assert AD({}) == {}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "4d57e10f",
   "metadata": {},
   "outputs": [],
   "source": [
    "p = 1\n",
    "q = {\"a\": 10}\n",
    "s = AD(p, q, a=20, b=30)\n",
    "assert s == {\"a\": 20, \"b\": 30, \"p\": 1, \"q\": {\"a\": 10}}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 6,
   "id": "15874dfe",
   "metadata": {},
   "outputs": [],
   "source": [
    "s = AD(p, **q, b=30)\n",
    "assert s == {\"a\": 10, \"b\": 30, \"p\": 1}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 10,
   "id": "2e3ddb52",
   "metadata": {},
   "outputs": [
    {
     "data": {
      "text/plain": [
       "\n",
       "```↯ AttrDict ↯\n",
       "p\n",
       "  b - 222 (🏷️ int)\n",
       "a - 20 (🏷️ int)\n",
       "b - 30 (🏷️ int)\n",
       "bb - 2 (🏷️ int)\n",
       "\n",
       "```"
      ]
     },
     "execution_count": 10,
     "metadata": {},
     "output_type": "execute_result"
    }
   ],
   "source": [
    "AD(p, {\"a\": 2, \"b\": 2}, {\"bb\": 2, \"a\": 3, \"b\": 3}, a=20, b=30)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 11,
   "id": "fa382965",
   "metadata": {},
   "outputs": [],
   "source": [
    "p = {\"b\": 222}\n",
    "assert AD(p, {\"a\": 2, \"b\": 2}, {\"bb\": 2, \"a\": 3, \"b\": 3}, a=20, b=30) == {\n",
    "    \"a\": 20,\n",
    "    \"b\": 30,\n",
    "    \"bb\": 2,\n",
    "    \"p\": {\"b\": 222},\n",
    "}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 16,
   "id": "d12c0c76",
   "metadata": {},
   "outputs": [],
   "source": [
    "a = 20\n",
    "b = 30\n",
    "assert AD(a, b).to_dict() == {\"a\": 20, \"b\": 30}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "1e781188",
   "metadata": {},
   "outputs": [],
   "source": [
    "p = 10\n",
    "q = {\"a\": 1}\n",
    "assert AD(p, q) == {\"p\": 10, \"q\": {\"a\": 1}}\n",
    "assert AD(p, {\"a\": 1}) == {\"p\": 10, \"a\": 1}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "30b3d187",
   "metadata": {},
   "outputs": [],
   "source": [
    "x = {\"a\": 1, \"b\": 2, \"c\": 3}\n",
    "y = {\"d\": 4}\n",
    "assert AD(x, y) == {\"x\": {\"a\": 1, \"b\": 2, \"c\": 3}, \"y\": {\"d\": 4}}\n",
    "assert AD(**x, **y) == {\"a\": 1, \"b\": 2, \"c\": 3, \"d\": 4}"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c77bb757",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "ts",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.12.4"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
